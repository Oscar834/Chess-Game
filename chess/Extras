import os
import operator
import pygame

# This dictionary is used to map a string to its correct operator using the in-buit operator module.
operators = {'+': operator.add, '-': operator.sub}

class Piece:
    def __init__(self, name, colour, image=None, imageRect=None):
        self.name = name
        self.colour = colour
        self.image = image
        self.DisplayPieceImages()
        self.imageRect = imageRect

    def DisplayPieceImages(self):
        self.image = os.path.join(f"Piece Images/{self.colour} {self.name}.png")

class Pawn(Piece):
    def __init__(self, colour):
        # Using inheritance so I don't have to write all the code in the __init__ method for each piece.
        super().__init__('Pawn', colour)

    def GetValidMoves(self, board, row, column, condition=None):
        moves = []
        currentSquare = board[row][column]

        # Checks the colour of the piece at the current row and column
        if currentSquare.piece.colour == 'White':
            direction = -1 # White moves up
        else:
            direction = 1 # Black moves down

         # Checks if the pawns are on their starting rows to allow them move two squares up but checks if both squares are empty first
        if (currentSquare.piece.colour == 'White' and row == 6) or (currentSquare.piece.colour == 'Black' and row == 1):
            if board[row + direction][column].piece is None and board[row + 2 * direction][column].piece is None:
                moves.append((row + 2 * direction, column))
        
        # Allows the pawns move one square up as normal
        if 0 <= row + direction <= 7 and board[row + direction][column].piece is None:
            moves.append((row + direction, column))
        
            # Responsible for diagonal captures
            for col in [-1, 1]:
                newColumn = column + col
                
                # Checks if the diagonal capture squares are within bounds of the board
                # But doesn't consider the last row because row + direction (7 + 1) would go out of bounds 
                if 1 <= newColumn <= 8 and row < 7:
                    newSquare = board[row + direction][newColumn]

                    # Checks to ensure an opponent piece is present for a diagonal capture to be possible
                    if newSquare.piece != None and newSquare.piece.colour != currentSquare.piece.colour:
                        moves.append((row + direction, newColumn))

        if condition == 'Control':
            return self.GetControlMoves(board, row, column)
                
        return moves
    
    def GetControlMoves(self, board, row, column):
        moves = []
        currentSquare = board[row][column]

        if currentSquare.piece.colour == 'White':
            direction = -1 # White moves up
        else:
            direction = 1 # Black moves down

        for col in [-1, 1]:
            newColumn = column + col
            
            # Checks if the diagonal capture squares are within bounds of the board
            # But doesn't consider the last row because row + direction (7 + 1) would go out of bounds 
            if 1 <= newColumn <= 8 and row < 7:
                newSquare = board[row + direction][newColumn]

                # Checks if the square is empty or contains a friendly piece so it can defend that piece from the king.
                if newSquare.piece == None or (newSquare.piece.colour == currentSquare.piece.colour):
                    moves.append((row + direction, newColumn))
                
        return moves

class Bishop(Piece):
    def __init__(self, colour):
        super().__init__('Bishop', colour)

    def GetValidMoves(self, board, row, column, condition=None):
        moves = []

        # The pair (+, +) is responsible for getting the moves for the bishop in the top-left to bottom-right diagonal
        # The pair(-, -) is responsible for getting the moves for the bishop in the bottom-right to top-left diagonal
        # The pair (+, -) is responsible foe getting the moves for the bishop in the top-right to bottom-left diagonal
        # The pair (-, +) is responsible for getting the moves for the bishop in the bottom-left to top-right diagonal
        operatorPairs = [('+', '+'), ('-', '-'), ('+', '-'), ('-', '+')]

        for ops in operatorPairs:
            for direction in range(1, 8): # This for loop with the help of the first loops checks the squares in all directions
                op1 = operators[ops[0]] # Gets the first element of the tuple
                op2 = operators[ops[1]] # Gets the second element of the tuple
                newRow = op1(row, direction) # Same as newRow = row + direction (operator depends on first element of each tuple iterated)
                newColumn = op2(column, direction) # Same as newColumn  = row + direction (operator depends on second element of each tuple iterated)

                # Checks to see if the new row and column to move to is within the bounds of the board
                if 0 <= newRow <= 7 and 1 <= newColumn <= 8:
                    newSquare = board[newRow][newColumn] # It would be None if the square is empty
                    currentSquare = board[row][column]

                    # This if block is responsible for normal valid moves
                    if condition == None:
                        # Checks if the square to move to is empty
                        if newSquare.piece == None:
                            moves.append((newRow, newColumn))
                        # Checks if an enemy piece has been encountered
                        elif currentSquare.piece.colour != newSquare.piece.colour:
                            moves.append((newRow, newColumn))
                            # If it encounters an enemy piece, it stops so no more moves are added along that direction
                            break
                        else:
                            # It stops if it encounters a friendly piece
                            break

                    # This elif block is responsible for the moves that are used to control king movement
                    elif condition == 'Control':
                        # Checks if the square to move to is empty
                        if newSquare.piece == None:
                            moves.append((newRow, newColumn))
                        # Checks if a friendly piece has been encountered and adds it so it can defend it from the king
                        elif currentSquare.piece.colour == newSquare.piece.colour:
                            moves.append((newRow, newColumn))
                            # If it encounters a piece of the same colour, it stops so no more moves are added along that direction
                            break
                        # If the piece it encounters is an enemy king, it skips that square and adds the ones behind it.
                        elif newSquare.piece.name == 'King' and currentSquare.piece.colour != newSquare.piece.colour:
                            continue
                        else:
                            # If it encounters an enemy piece that is not a king, it stops.
                            break
                
        return moves

class Knight(Piece):
    def __init__(self, colour):
        super().__init__('Knight', colour)

    def GetValidMoves(self, board, row, column, condition=None):
        moves = []

        operatorPairs = [('-', '+'), ('+', '+')]
        direction1 = 1
        direction2 = 2

        for ops in operatorPairs:
            # This is responsible for the L-Movement that is 2 squares up/down and then 1 square left/right
            for col in [-1, 1]:
                op1 = operators[ops[0]]
                op2 = operators[ops[1]]
                newRow = op1(row, direction2) # Gets the row 2 squares up (op1 = -) or 2 squares down (op1 = +)
                newColumn = op2(column, col) # Gets the column 1 to the left if col = - or 1 to the right if col = 1

                if 0 <= newRow <= 7 and 1 <= newColumn <= 8:
                    newSquare = board[newRow][newColumn]
                    currentSquare = board[row][column]
                    
                    if condition == None:
                        # Checks if the square encountered is empty or contains an enemy piece
                        if newSquare.piece == None or currentSquare.piece.colour != newSquare.piece.colour:
                            moves.append((newRow, newColumn))
                    elif condition == 'Control':
                        # Checks if the square encountered is empty or contains a friendly piece so it can defend it from the king
                        if newSquare.piece == None or currentSquare.piece.colour == newSquare.piece.colour:
                            moves.append((newRow, newColumn))

            # This is responsible for the L-Movement that is 1 square up/down and then 2 squares left/right
            for col in [-2, 2]:
                newRow = op1(row, direction1) # Gets the row 1 squares up (op1 = -) or 1 squares down (op1 = +)
                newColumn = op2(column, col) # Gets the column 2 to the left if col = - or 2 to the right if col = 1

                if 0 <= newRow <= 7 and 1 <= newColumn <= 8:
                    newSquare = board[newRow][newColumn]

                    # This if block is responsible for normal valid moves
                    if condition == None:
                        # Checks if the square encountered is empty or contains an enemy piece
                        if newSquare.piece == None or currentSquare.piece.colour != newSquare.piece.colour:
                            moves.append((newRow, newColumn))
                    
                    # This elif block is responsible for the moves that are used to control king movement
                    elif condition == 'Control':
                        # Checks if the square encountered is empty or contains a friendly piece so it can defend it from the king
                        if newSquare.piece == None or currentSquare.piece.colour == newSquare.piece.colour:
                            moves.append((newRow, newColumn))

        return moves
   
class Rook(Piece):
    def __init__(self, colour):
        super().__init__('Rook', colour)

    def GetValidMoves(self, board, row, column, condition=None):
        moves = []

        operatorPairs = ['+', '-'] # + is for down/right, - is for up/left

        for ops in operatorPairs:
            # Responsible for vertical moves
            for direction in range(1, 8):
                op1 = operators[ops] # Maps the string in operator pairs to the correct operator in the operators dictionary
                newRow = op1(row, direction) # Performs the correct operation

                if 0 <= newRow <= 7:
                    newSquare = board[newRow][column]
                    currentSquare = board[row][column]
                    
                    # This if block is responsible for the normal valid moves
                    if condition == None:
                        # Checks if the encountered square is empty
                        if newSquare.piece == None:
                            moves.append((newRow, column))
                        # Checks if the new square contains an enemy piece
                        elif currentSquare.piece.colour != newSquare.piece.colour:
                            moves.append((newRow, column))
                            # If it encounters an enemy piece, it stops so no more moves are added along that direction
                            break
                        else:
                            # It stops if it encounters a friendly piece
                            break
                    
                    # This elif block is responsible for the moves that are used to control king movement
                    elif condition == 'Control':
                        # Checks if the encountered square is empty
                        if newSquare.piece == None:
                            moves.append((newRow, column))
                        # Checks if the new square contains a friendly piece so it can defend it from the king
                        elif currentSquare.piece.colour == newSquare.piece.colour:
                            moves.append((newRow, column))
                            # If it encounters a friendly piece, it stops so no more moves are added along that direction
                            break
                        # If the piece it encounters is an enemy king, it skips that square and adds the ones behind it.
                        elif newSquare.piece.name == 'King' and currentSquare.piece.colour != newSquare.piece.colour:
                            continue
                        else:
                            # If it encounters an enemy piece that is not a king, it stops.
                            break
                    
            # Responsible for horizontal moves
            for direction in range(1, 8):
                newColumn = op1(column, direction) # Perform the correct operation on column and direction

                if 1 <= newColumn <= 8:
                    newSquare = board[row][newColumn]
                    # This if block is responsible for the normal valid moves
                    if condition == None:
                        # Checks if the new square is empty
                        if newSquare.piece == None:
                            moves.append((row, newColumn))
                        # Checks if an enemy piece has been encountered
                        elif currentSquare.piece.colour != newSquare.piece.colour:
                            moves.append((row, newColumn))
                            # If it encounters an enemy piece, it stops so no more moves are added along that direction
                            break
                        else:
                            # It stops if it encounters a friendly piece
                            break

                    # This elif block is responsible for the moves that are used to control king movement
                    elif condition == 'Control':
                        # Checks if the new square is empty
                        if newSquare.piece == None:
                            moves.append((row, newColumn))
                        # Checks if a friendly piece has been encountered so it can defend it from the king
                        elif currentSquare.piece.colour == newSquare.piece.colour:
                            moves.append((row, newColumn))
                            # If it encounters a friendly piece, it stops so no more moves are added along that direction
                            break
                        # If the piece it encounters is an enemy king, it skips that square and adds the ones behind it.
                        elif newSquare.piece.name == 'King' and currentSquare.piece.colour != newSquare.piece.colour:
                            continue
                        else:
                            # If it encounters an enemy piece that is not a king, it stops.
                            break
                    
        return moves

class Queen(Piece):
    def __init__(self, colour):
        super().__init__('Queen', colour)
        self.rook = Rook(colour) # Instantiates the rook piece class so it can use its methods
        self.bishop = Bishop(colour) # Instantiates the bishop piece class so it can use it methods

    def GetValidMoves(self, board, row, column, condition=None):
        moves = []

        # It adjusts appropriately depending on the condition
        if condition != None:
            moves.extend(self.rook.GetValidMoves(board, row, column, condition))
            moves.extend(self.bishop.GetValidMoves(board, row, column, condition))
        else:
            # The queen just has the moves of the rook and a bishop combined
            moves.extend(self.rook.GetValidMoves(board, row, column))
            moves.extend(self.bishop.GetValidMoves(board, row, column))
       
        return moves

class King(Piece):
    def __init__(self, colour):
        super().__init__('King', colour)

    def GetValidMoves(self, board, row, column, condition=None):
        moves = []
        direction = 1
        
        # Responsible for movement in the top left and bottom right directions
        for dir in [-1, 1]:
            newRow = row + dir
            newColumn = column + dir
        
            #Checks if the new row and new column are within the bounds of the board
            if 0 <= newRow <= 7 and 1 <= newColumn <= 8:
                square = board[newRow][newColumn]
                piece = square.piece
                piece2 = board[row][column].piece

                if condition == None:
                    #Checks if the square it's moving to is empty
                    if piece == None:
                        moves.append((newRow, newColumn))
                    #Checks if the piece at the square it's moving to is of a different colour and not a king
                    elif piece2.colour != piece.colour:
                        moves.append((newRow, newColumn))
                elif condition == 'Control':
                    #Checks if the square it's moving to is empty
                    if piece == None:
                        moves.append((newRow, newColumn))
                    #Checks if the piece at the square it's moving to is of a different colour and not a king
                    elif piece2.colour == piece.colour:
                        moves.append((newRow, newColumn))

        #Responsible for movement in the horizontal left and right directions
        for dir in [-1, 1]:
            newColumn = column + dir

            if 1 <= newColumn <= 8:
                square = board[row][newColumn]
                piece = square.piece
                piece2 = board[row][column].piece

                if condition == None:
                    if piece == None: 
                        moves.append((row, newColumn))
                    elif piece2.colour != piece.colour:
                        moves.append((row, newColumn))
                elif condition == 'Control':
                    if piece == None: 
                        moves.append((row, newColumn))
                    elif piece2.colour == piece.colour:
                        moves.append((row, newColumn))

        #Responsible for movement in the vertical top and bottom directions
        for dir in [-1, 1]:
            newRow = row + dir

            if 0 <= newRow <= 7:
                square = board[newRow][column]
                piece = square.piece
                piece2 = board[row][column].piece

                if condition == None:
                    if piece == None:
                        moves.append((newRow, column))
                    elif piece2.colour != piece.colour:
                        moves.append((newRow, column))
                elif condition == 'Control':
                    if piece == None:
                        moves.append((newRow, column))
                    elif piece2.colour == piece.colour:
                        moves.append((newRow, column))

        #Responsible for movement in the bottom left direction
        if 0 <= row + direction <= 7 and 1 <= column - direction <= 8:
            square = board[row + direction][column - direction]
            piece = square.piece
            piece2 = board[row][column].piece

            if condition == None:
                if piece == None:
                    moves.append((row + direction, column - direction))
                elif piece2.colour != piece.colour:
                    moves.append((row + direction, column - direction))
            elif condition == 'Control':
                if piece == None:
                    moves.append((row + direction, column - direction))
                elif piece2.colour == piece.colour:
                    moves.append((row + direction, column - direction))

        #Responsible for movement in the top right direction
        if 0 <= row - direction <= 7 and 1 <= column + direction <= 8:
            square = board[row - direction][column + direction]
            piece = square.piece
            piece2 = board[row][column].piece

            if condition == None:
                if piece == None:
                    moves.append((row - direction, column + direction))
                elif piece2.colour != piece.colour:
                    moves.append((row - direction, column + direction))
            elif condition == 'Control':
                if piece == None:
                    moves.append((row - direction, column + direction))
                elif piece2.colour == piece.colour:
                    moves.append((row - direction, column + direction))

        return moves

    def GetShortCastleMoves(self, board, row, column):
        moves = []
        # Checks if it the kings are on their starting squares. (7, 5) for white and (0, 5) for black 
        if (row == 7 or row == 0) and column == 5:
            # Checks if the squares between the king and the king's rook are empty
            if board[row][column + 1].piece == None and board[row][column + 2].piece == None:
                moves.append((row, column + 2))

        return moves
    
    def GetLongCastleMoves(self, board, row, column):
        moves = []
        # Checks if the kings are on their starting squares
        if (row == 7 or row == 0) and column == 5:
            # Checks if the three squares between the king and the queen's rook are empty
            if board[row][column - 1].piece == None and board[row][column - 2].piece == None and board[row][column - 3].piece == None:
                moves.append((row, column - 2))

        return moves
    
import pygame
import sys
from chess.Button import Button
from chess.Constants import BLACK, SQUARE_HEIGHT, SQUARE_WIDTH
from chess.GameManager import Game

pygame.init()
gameWindow = pygame.display.set_mode((1000, 800))
gameIcon = pygame.image.load('images/king.png')
pygame.display.set_icon(gameIcon)

pygame.display.set_caption('Chess')

mainText = pygame.font.SysFont('Arial', 120, bold=True)
game = Game(gameWindow) # Creates an instance of the game class and passes the game window as the screen parameter

# Function that first converts the text into an image in order to allow it to be displayed on the screen
def DisplayText(text, font, color, x, y):
    image = font.render(text, True, color)
    gameWindow.blit(image, (x, y))

def SelectedRowColumn(mousePosition):
    x, y = mousePosition # Gets the x and y coordinates of the mousePosition passed
    row = y // SQUARE_WIDTH # Determines the row by performing the correct division with the y coordinate
    column = x // SQUARE_HEIGHT # Determines the column by performing the correct division with the x coordinate
    return row, column

def Play():
    running = True

    while running:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False

            # Checks if the mouse has been left clicked
            if event.type == pygame.MOUSEBUTTONDOWN and pygame.mouse.get_pressed()[0] == 1:
                mousePosition = pygame.mouse.get_pos() # Gets the current position of the mouse
                row, column = SelectedRowColumn(mousePosition) # Gets the row and column from the mouse's current position
                game.SelectSquare(row, column) # Calls the SelectSquare method to allow for piece selection and movement

        game.UpdateScreen() # Calls the UpdateScreen from the game class so it can carry out the visuals display on the screen

import pygame
import sys
from chess.Button import Button
from chess.Constants import SQUARE_HEIGHT, SQUARE_WIDTH, WHITE, GREEN, BLACK, GREY, BLUE, BROWN 
from chess.GameManager import Game
from chess.Board import Board
from chess.AI import Minimax, EasyMode, MediumMode, HardMode
from copy import deepcopy

pygame.init()
pygame.mixer.init()

gameWindow = pygame.display.set_mode((1000, 800))
gameIcon = pygame.image.load('images/king.png')
pygame.display.set_icon(gameIcon)
clock = pygame.time.Clock()
fps = 60

pygame.display.set_caption('Chess')

mainText = pygame.font.SysFont('Arial', 120, bold=True)
diffText = pygame.font.SysFont('Arial', 100, bold=True)
subText = pygame.font.SysFont('Arial', 50)
game = Game(gameWindow)
board = Board()

checkSFX = pygame.mixer.Sound('Sounds/Check sound.mp3')
playerMoveSFX = pygame.mixer.Sound('Sounds/Player Move.mp3')
oppMoveSFX = pygame.mixer.Sound('Sounds/Opp Move.mp3')
gameEndSFX = pygame.mixer.Sound('Sounds/Game end.mp3')
lowTimeSFX = pygame.mixer.Sound('Sounds/Timer Sound.mp3')
castleSFX = pygame.mixer.Sound('Sounds/Castle sound.mp3')
takeImage = pygame.image.load('images/Takeback.png')
takeBackButton = Button(10, 700, takeImage, 1.2)

#Function that first converts the text into an image in order to allow it to be displayed on the screen
def DisplayText(text, font, color, x, y):
    image = font.render(text, True, color)
    gameWindow.blit(image, (x, y))

def SelectedRowColumn(mousePosition):
    x, y = mousePosition # Gets the x and y coordinate of the mouse position passed
    row = y // SQUARE_WIDTH # Determines the row by performing the correct division with the y coordinate
    column = x // SQUARE_HEIGHT # Determines the column by performing the correct division with the x coordinate
    return row, column


def Play(time, colour=None):
    running = True
    FONT = pygame.font.SysFont('Roboto Mono', 50)
    boardColours = {'Blue': BLUE, 'Brown': BROWN, 'Green': GREEN} # Maps the colour parameter to the correct colour constant 
    boardColour = boardColours.get(colour) # Gives the board the correct colour theme depending on the colour parameter 
                                           #(i.e board colour chosen from settings menu)   

    # Initialises timer values for white and black depending on the timer option chosing in the timer selection menu
    whiteSeconds = time * 60
    blackSeconds = time * 60
    pygame.time.set_timer(pygame.USEREVENT, 1000)

    while running:
         
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False

            # Checks if the mouse has been left clicked
            if event.type == pygame.MOUSEBUTTONDOWN and pygame.mouse.get_pressed()[0] == 1:
                mousePosition = pygame.mouse.get_pos() # Gets the current position of the mouse
                row, column = SelectedRowColumn(mousePosition) # Gets the row and column from the mouse's current position
                game.SelectSquare(row, column) # Calls the SelectSquare method to allow for piece selection and movement
                
            if event.type == pygame.USEREVENT:
                # Checks if it is currently white's turn
                if game.turn == 'White':
                    # Makes white's time tick down
                    whiteSeconds -= 1
                else:
                    # Makes black' time tick down
                    blackSeconds -= 1
    
        # Draws the rectangles on which the timers would appear
        pygame.draw.rect(gameWindow, WHITE, (1, 375, 98, 50))
        pygame.draw.rect(gameWindow, BLACK, (901, 375, 98, 50))

        # Displays white's timer and ensures the timer doesn't go into the negatives
        if whiteSeconds >= 0:
            whiteMinutes = whiteSeconds // 60
            whiteSecs = whiteSeconds % 60
        # Responsible for converting the display into the correct format by using zero padding for seconds
        whiteTimerText = FONT.render(f"{whiteMinutes}:{whiteSecs:02}", True, BLACK)
        whiteTimerRect = whiteTimerText.get_rect(center=(49, 400))
        gameWindow.blit(whiteTimerText, whiteTimerRect) # Displays the timers onto the screen

        # Displays black's timer and ensures the timer doesn't go into the negatives
        if blackSeconds >= 0:
            blackMinutes = blackSeconds // 60
            blackSecs = blackSeconds % 60
        #Responsible for converting the display into the correct format by using zero padding for seconds
        blackTimerText = FONT.render(f"{blackMinutes}:{blackSecs:02}", True, WHITE)
        blackTimerRect = blackTimerText.get_rect(center=(949, 400))
        gameWindow.blit(blackTimerText, blackTimerRect) # Displays the timers onto the screen

        pygame.display.update()
        game.UpdateScreen(boardColour) # Now calls the Update Screen with a board Colour parameter so the correct board theme is rendered
        clock.tick(fps)

    def Play(time, boardColour, sound, difficulty=None):
        running = True
        targetMenu = None
        playedMoves = []
        
        checkSFXPlayed = False
        playerMoveSFXPlayed = False
        oppMoveSFXPlayed = False
        wtimeSFXPlayed = False
        btimeSFXPlayed = False
        TIMER_FONT = pygame.font.SysFont('Roboto Mono', 50)

        # Initialises timer values for white and black depending on the timer option choice from the timer selection menu
        whiteSeconds = time * 60 # Converts to seconds becuase time from timer menu is given in minutes
        blackSeconds = time * 60
        pygame.time.set_timer(pygame.USEREVENT, 1000) # Triggers a USEREVENT every 1000 milliseconds (i.e. 1 second)

        moves = [deepcopy(board)]
        count = 1
        while running:
            if game.turn == 'Black' and difficulty == 'Easy':
                newBoard = EasyMode(game.GetBoard(),game)
                game.AIMovement(newBoard)
                moves.append(deepcopy(newBoard))

            if game.turn == 'Black' and difficulty == 'Medium':
                newBoard = MediumMode(game.GetBoard(), game)
                game.AIMovement(newBoard)
                moves.append(deepcopy(newBoard))

            if game.turn == 'Black' and difficulty == 'Hard':
                newBoard = HardMode(game.GetBoard(), game)
                game.AIMovement(newBoard)
                moves.append(deepcopy(newBoard))

            if difficulty == None and takeBackButton.Clicked(gameWindow):
                #print(game.MoveHistory)
                for moves in game.MoveHistory:
                    playedMoves.extend(game.MoveNotation(moves))

                print(playedMoves)
                #print(board.Display(AllMoves(board, 'Black', game)[18]))

            if takeBackButton.Clicked(gameWindow) and difficulty != None: #and count <= 3:
                count += 1
                if len(moves) > 1:
                    moves.pop()
                actualBoard = moves[-1]
                game.AIBoard(deepcopy(actualBoard))

            if game.InCheck(game.turn) != None and not checkSFXPlayed and sound == 'On':
                checkSFX.play()
                checkSFXPlayed = True

            elif game.InCheck(game.turn) == None: #Error
                checkSFXPlayed = False

            if game.turn == 'White' and not playerMoveSFXPlayed and game.InCheck(game.turn) == None and sound == 'On':
                playerMoveSFX.play()
                playerMoveSFXPlayed = True
                oppMoveSFXPlayed = False

            elif game.turn == 'Black' and not oppMoveSFXPlayed and game.InCheck(game.turn) == None and sound == 'On':
                oppMoveSFX.play()
                oppMoveSFXPlayed = True
                playerMoveSFXPlayed = False

            if whiteSeconds < 10 and not wtimeSFXPlayed and sound == 'On':
                lowTimeSFX.play()
                wtimeSFXPlayed = True

            if blackSeconds < 10 and not btimeSFXPlayed and sound == 'On':
                lowTimeSFX.play()
                btimeSFXPlayed = True

            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    running = False

                # Checks if the mouse has been left clicked
                if event.type == pygame.MOUSEBUTTONDOWN and pygame.mouse.get_pressed()[0] == 1:
                    mousePosition = pygame.mouse.get_pos() # Gets the current position of the mouse
                    row, column = SelectedRowColumn(mousePosition) # Gets the row and column from the mouse's current position
                    game.SelectSquare(row, column) # Calls the SelectSquare method to allow for piece selection and movement
                    
                if event.type == pygame.USEREVENT:
                    # Checks if it is currently white's turn
                    if game.turn == 'White':
                        # Makes white's time tick down
                        whiteSeconds -= 1
                    else:
                        # Makes black' time tick down
                        blackSeconds -= 1

            if game.Checkmate('Black'):
                if sound == 'On':
                    gameEndSFX.play()
                targetMenu = 'White Checkmate'
                game.board = deepcopy(board)
                game.turn = 'White'
                running = False

            if game.Checkmate('White'):
                if sound == 'On':
                    gameEndSFX.play()
                targetMenu = 'Black Checkmate'
                game.board = deepcopy(board)
                game.turn = 'White'
                running = False

            if game.Stalemate():
                if sound == 'On':
                    gameEndSFX.play()
                targetMenu = 'Stalemate'
                game.board = deepcopy(board)
                game.turn = 'White'
                running = False
            if game.InsufficientMaterial():
                if sound == 'On':
                    gameEndSFX.play()
                targetMenu = 'Insufficient Material'
                game.board = deepcopy(board)
                game.turn = 'White'
                running = False
            if whiteSeconds == 0:
                if sound == 'On':
                    gameEndSFX.play()
                targetMenu = 'Black win time'
                game.board = deepcopy(board)
                running = False
            if blackSeconds == 0:
                if sound == 'On':
                    gameEndSFX.play()
                targetMenu = 'White win time'
                game.board = deepcopy(board)
                game.turn = 'White'
                running = False
        
            # Draws the rectangles on which the timers would appear
            pygame.draw.rect(gameWindow, WHITE, (1, 375, 98, 50))
            pygame.draw.rect(gameWindow, BLACK, (901, 375, 98, 50))

            # Checks if white's time is greater than 0 to enusre it doesn't go into the negatives
            if whiteSeconds >= 0:
                whiteMinutes = whiteSeconds // 60 # The minute part in the timer
                whiteSecs = whiteSeconds % 60 # The second part in the timer
            # Responsible for converting the display into the correct format by using zero padding for seconds
            whiteTimerText = TIMER_FONT.render(f"{whiteMinutes}:{whiteSecs:02}", True, BLACK)
            whiteTimerRect = whiteTimerText.get_rect(center=(49, 400))
            gameWindow.blit(whiteTimerText, whiteTimerRect) # Displays white's timer onto the screen

            # Checks if black's time is greater than 0 to ensure it doesn't go into the negatives
            if blackSeconds >= 0:
                blackMinutes = blackSeconds // 60 # The minute part in the timer 
                blackSecs = blackSeconds % 60 # The second part in the timer
            # Responsible for converting the display into the correct format by using zero padding for seconds
            blackTimerText = TIMER_FONT.render(f"{blackMinutes}:{blackSecs:02}", True, WHITE)
            blackTimerRect = blackTimerText.get_rect(center=(949, 400))
            gameWindow.blit(blackTimerText, blackTimerRect) # Displays black's timer onto the screen

            pygame.display.update()
            game.UpdateScreen(boardColour) # Calls Update Screen with a board Colour parameter so the correct board theme is rendered
            clock.tick(fps)

        if targetMenu == 'White Checkmate':
            EndScreen('win', 'Checkmate', time, sound, difficulty, boardColour, 'White')
        elif targetMenu == 'Black Checkmate':
            EndScreen('win', 'Checkmate', time, sound, difficulty, boardColour, 'Black')
        elif targetMenu == 'Stalemate':
            EndScreen('draw', 'Stalemate', time, sound, difficulty, boardColour)
        elif targetMenu == 'Insufficient Material':
            EndScreen('draw', 'Insufficient Material', time, sound, difficulty, boardColour)
        elif targetMenu == 'Black win time':
            EndScreen('win', 'Timeout', time, sound, difficulty, boardColour, 'Black')
        elif targetMenu == 'White win time':
            EndScreen('win', 'Timeout', time, sound, difficulty, boardColour, 'White')

    def Play(time, boardColour, sound, difficulty=None):
        running = True
        targetMenu = None
        playedMoves = []
        
        checkSFXPlayed = False
        playerMoveSFXPlayed = False
        oppMoveSFXPlayed = False
        wtimeSFXPlayed = False
        btimeSFXPlayed = False
        TIMER_FONT = pygame.font.SysFont('Roboto Mono', 50)

        # Initialises timer values for white and black depending on the timer option choice from the timer selection menu
        whiteSeconds = time * 60 # Converts to seconds becuase time from timer menu is given in minutes
        blackSeconds = time * 60
        pygame.time.set_timer(pygame.USEREVENT, 1000) # Triggers a USEREVENT every 1000 milliseconds (i.e. 1 second)

        AI_MOVEMENT = pygame.USEREVENT + 1
        ai_event_scheduled = False  # Flag to track if the AI move event is already scheduled

        moves = [deepcopy(board)]
        count = 1
        while running:
            if difficulty == None and takeBackButton.Clicked(gameWindow):
                #print(game.MoveHistory)
                for moves in game.MoveHistory:
                    playedMoves.extend(game.MoveNotation(moves))

                print(playedMoves)
                #print(board.Display(AllMoves(board, 'Black', game)[18]))

            if takeBackButton.Clicked(gameWindow) and difficulty != None: #and count <= 3:
                count += 1
                if len(moves) > 1:
                    moves.pop()
                previousBoard = moves[-1]
                game.AIBoard(deepcopy(previousBoard))

            if game.InCheck(game.turn) != None and not checkSFXPlayed and sound == 'On':
                checkSFX.play()
                checkSFXPlayed = True

            elif game.InCheck(game.turn) == None: #Error
                checkSFXPlayed = False

            if game.turn == 'White' and not playerMoveSFXPlayed and game.InCheck(game.turn) == None and sound == 'On':
                playerMoveSFX.play()
                playerMoveSFXPlayed = True
                oppMoveSFXPlayed = False

            elif game.turn == 'Black' and not oppMoveSFXPlayed and game.InCheck(game.turn) == None and sound == 'On':
                oppMoveSFX.play()
                oppMoveSFXPlayed = True
                playerMoveSFXPlayed = False

            if whiteSeconds < 10 and not wtimeSFXPlayed and sound == 'On':
                lowTimeSFX.play()
                wtimeSFXPlayed = True

            if blackSeconds < 10 and not btimeSFXPlayed and sound == 'On':
                lowTimeSFX.play()
                btimeSFXPlayed = True

            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    running = False

                # Checks if the mouse has been left clicked
                if event.type == pygame.MOUSEBUTTONDOWN and pygame.mouse.get_pressed()[0] == 1:
                    mousePosition = pygame.mouse.get_pos() # Gets the current position of the mouse
                    row, column = SelectedRowColumn(mousePosition) # Gets the row and column from the mouse's current position
                    game.SelectSquare(row, column) # Calls the SelectSquare method to allow for piece selection and movement
                    
                if event.type == pygame.USEREVENT:
                    # Checks if it is currently white's turn
                    if game.turn == 'White':
                        # Makes white's time tick down
                        whiteSeconds -= 1
                    else:
                        # Makes black' time tick down
                        blackSeconds -= 1

                # AI move handling
                if event.type == AI_MOVEMENT:
                    print("AI move event triggered!")
                    if game.turn == 'Black':  # Ensure it's still AI's turn
                        print("AI is attempting to move...")
                        if difficulty == 'Easy':
                            newBoard = EasyMode(game.GetBoard(), game)
                        elif difficulty == 'Medium':
                            newBoard = MediumMode(game.GetBoard(), game)
                        elif difficulty == 'Hard':
                            newBoard = HardMode(game.GetBoard(), game)

                        game.AIMovement(newBoard)
                        moves.append(deepcopy(newBoard))
                        print("AI moved successfully!")

                        ai_event_scheduled = False 

            # Outside the event loop: Post an AI move event when it's the AI's turn
            if game.turn == 'Black' and difficulty and not ai_event_scheduled:
                pygame.time.set_timer(AI_MOVEMENT, 500, True)  # Delay AI move
                ai_event_scheduled = True
                print("AI move event scheduled!")

    def Play(time, boardColour, sound, difficulty=None):
    running = True
    targetMenu = None
    playedMoves = []
    
    checkSFXPlayed = False
    playerMoveSFXPlayed = False
    oppMoveSFXPlayed = False
    wtimeSFXPlayed = False
    btimeSFXPlayed = False
    TIMER_FONT = pygame.font.SysFont('Roboto Mono', 50)

    # Initialises timer values for white and black depending on the timer option choice from the timer selection menu
    whiteSeconds = time * 60 # Converts to seconds becuase time from timer menu is given in minutes
    blackSeconds = time * 60
    pygame.time.set_timer(pygame.USEREVENT, 1000) # Triggers a USEREVENT every 1000 milliseconds (i.e. 1 second)

    AIMOVEMENT = pygame.USEREVENT + 1
    TURNSWITCH = pygame.USEREVENT + 2

    moves = [deepcopy(board)]
    count = 1
    while running:
        if difficulty == None and takeBackButton.Clicked(gameWindow):
            #print(game.MoveHistory)
            for moves in game.MoveHistory:
                playedMoves.extend(game.MoveNotation(moves))

            print(playedMoves)
            #print(board.Display(AllMoves(board, 'Black', game)[18]))

        if takeBackButton.Clicked(gameWindow) and difficulty != None: #and count <= 3:
            count += 1
            if len(moves) > 1:
                moves.pop()
            previousBoard = moves[-1]
            game.AIBoard(deepcopy(previousBoard))

        if game.InCheck(game.turn) != None and not checkSFXPlayed and sound == 'On':
            checkSFX.play()
            checkSFXPlayed = True

        elif game.InCheck(game.turn) == None: #Error
            checkSFXPlayed = False

        if game.turn == 'White' and not playerMoveSFXPlayed and game.InCheck(game.turn) == None and sound == 'On':
            playerMoveSFX.play()
            playerMoveSFXPlayed = True
            oppMoveSFXPlayed = False

        elif game.turn == 'Black' and not oppMoveSFXPlayed and game.InCheck(game.turn) == None and sound == 'On':
            oppMoveSFX.play()
            oppMoveSFXPlayed = True
            playerMoveSFXPlayed = False

        if whiteSeconds < 10 and not wtimeSFXPlayed and sound == 'On':
            lowTimeSFX.play()
            wtimeSFXPlayed = True

        if blackSeconds < 10 and not btimeSFXPlayed and sound == 'On':
            lowTimeSFX.play()
            btimeSFXPlayed = True

        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False

            # Checks if the mouse has been left clicked
            if event.type == pygame.MOUSEBUTTONDOWN and pygame.mouse.get_pressed()[0] == 1:
                mousePosition = pygame.mouse.get_pos() # Gets the current position of the mouse
                row, column = SelectedRowColumn(mousePosition) # Gets the row and column from the mouse's current position
                game.SelectSquare(row, column) # Calls the SelectSquare method to allow for piece selection and movement
                
            if event.type == pygame.USEREVENT:
                # Checks if it is currently white's turn
                if game.turn == 'White':
                    # Makes white's time tick down
                    whiteSeconds -= 1
                else:
                    # Makes black' time tick down
                    blackSeconds -= 1

            if event.type == AIMOVEMENT:
                if game.turn == 'Black':
                    if difficulty == 'Easy':
                        newBoard = EasyMode(game.GetBoard(),game)
                    elif difficulty == 'Medium':
                        newBoard = MediumMode(game.GetBoard(), game)
                    elif difficulty == 'Hard':
                        newBoard = HardMode(game.GetBoard(), game)

                game.AIMovement(newBoard)
                moves.append(deepcopy(newBoard))
                
                pygame.event.post(pygame.event.Event(TURNSWITCH))

            if event.type == TURNSWITCH:
                game.turn = 'White'

        if game.turn == 'Black' and difficulty != None:
            pygame.event.post(pygame.event.Event(AIMOVEMENT))

from .Pieces import *
import math

class AIGame:
    def __init__(self):
        self.pawn = Pawn(Piece)
        self.bishop = Bishop(Piece)
        self.knight = Knight(Piece)
        self.rook = Rook(Piece)
        self.queen = Queen(Piece)
        self.king = King(Piece)
        self.squareSelected = None
        self.turn = 'White'
        self.validPieceMoves = []
    
    def PiecePositions(self, board, piece, colour):
        pieces = {1: None, 2: None, 3: None, 4: None, 5: None, 6: None, 7: None, 8: None, 9: None}
        positions = []

        for row in range(0, 8):
            for column in range(1, 9):
                # Row and column for enemy piece added to positions list
                if board.board[row][column].piece != None and board.board[row][column].piece.name == piece\
                and board.board[row][column].piece.colour == colour:
                    positions.append((row, column))

                    for key, value in zip(pieces.keys(), positions):
                        pieces[key] = value

        return pieces

    def PieceMoves(self, board, piece, colour):
        moves = {1: [], 2: [], 3: [], 4: [], 5: [], 6: [], 7: [], 8: [], 9: []}
        squares = []

        if piece == 'King':
            kingRow, kingColumn = self.PiecePositions(board, 'King', colour).get(1)
            # Adds the King moves to the squares list including cases where his movement is restricted
            squares.append(self.NewKingMoves(board, kingRow, kingColumn, colour)) 

            # Assigns the value in the squares list to the key '1' because there can only be one king
            for key, value in zip(moves.keys(), squares):
                moves[key] = value

        else:
            for num in range(1, 10):
                piecePosition = self.PiecePositions(board, piece, colour).get(num)
                if piecePosition != None:
                    pieceRow, pieceColumn = piecePosition
                    # Adds the updated moves for the piece to the squares list
                    squares.append(self.NewPieceMoves(board, pieceRow, pieceColumn, piece, colour))

                    # Assigns the value at each position in the squares to become the value of the corresponding key in the dictionary
                    for key, value in zip(moves.keys(), squares):
                        moves[key] = value

        return moves

    def KeyFromPosition(self, dict, position):
        # Loops through all key value pairs in the dictionary passed
        for key, value in dict.items():
            if value == position:
                return key # Returns the key from the value
            
        return None

    def CheckingPiecePosition(self, board, colour):
        positions = []
        for number in range(1, 10):
            for piece in ['Queen', 'Rook', 'Bishop', 'Knight', 'Pawn']:
                # Adds the position of any piece giving the check to the positions list
                positions.append(self.PieceCheck(board, piece, number, colour))

        return positions
    
    def BlockMoves(self, board, colour):
        moves = []
        for number in range(1, 10):
            for piece in ['Queen', 'Rook', 'Bishop']:
                # Adds the appropriate blocking moves to the moves list depending on the piece giving the check
                moves.extend(self.BlockPieceCheck(board, piece, number, colour))

        return moves
    
    def AllPieceMoves(self, board, colour):
        positions = []
        moves = []
        for row in range(0, 8):
            for column in range(1, 9):
                # This adds the positions of all the pieces of the current player to the positions list
                if board.board[row][column].piece != None and board.board[row][column].piece.colour == colour:
                    positions.append((row, column))

        # This loops through all the values now in the positions list and gets the piece using the row and column
        for pos in positions:
            piece = board.PieceAtSquare(pos[0], pos[1])
            # Depending on the piece, it adds it moves to the moves list accordingly
            if piece.name != 'King':
                moves.extend(self.NewPieceMoves(board, pos[0], pos[1], piece.name, colour))
            else:
                moves.extend(self.NewKingMoves(board, pos[0], pos[1], colour))

        return moves
    
    def Checkmate(self, board, colour):
        # Checks if the King is in check and whose turn it is
        if self.InCheck(board, colour) != None and colour == self.turn:
            # Checks if the list from AllPieceMoves is empty indicating checkmate as the king is in check
            if self.AllPieceMoves(board, colour) == []:
                return True
        
        return False
    
    def Stalemate(self, board):
        kingRow, kingColumn = self.PiecePositions(board, 'King', self.turn).get(1)
        # Checks if the King cannot move
        if self.NewKingMoves(board, kingRow, kingColumn, self.turn) == []:
            # Checks if the King is not in check but the AllMovesPiece list is empty indicating Stalemate
            if self.InCheck(board, self.turn) == None and self.AllPieceMoves(board, self.turn) == []:
                return True
        
        return False

    def PlayerPieces(self, board, colour):
        playerPieces = []

        for row in range(0, 8):
            for column in range(1, 9):
                # Adds the names of all the pieces of the white or black player (depending on colour) to the playerPieces list
                if board.board[row][column].piece != None and board.board[row][column].piece.colour == colour:
                    playerPieces.append(board.board[row][column].piece.name)

        return playerPieces
    
    def AllPieces(self, board):
        allPieces = []
        
        for row in range(0, 8):
            for column in range(1, 9):
                # Adds the name of all the pieces of every single piece on the board
                if board.board[row][column].piece != None:
                    allPieces.append(board.board[row][column].piece.name)

        return allPieces

    def InsufficientMaterial(self, board):
        whitePieces = self.PlayerPieces(board, 'White')
        blackPieces = self.PlayerPieces(board, 'Black')
        allPieces = self.AllPieces(board)

        if allPieces.count('King') == 2 and allPieces.count('Pawn') == 0 and allPieces.count('Knight') == 0\
        and allPieces.count('Bishop') == 0 and allPieces.count('Rook') == 0 and allPieces.count('Queen') == 0:
            return True
        
        elif allPieces.count('King') == 2 and allPieces.count('Pawn') == 0 and allPieces.count('Knight') == 1\
        and allPieces.count('Bishop') == 0 and allPieces.count('Rook') == 0 and allPieces.count('Queen') == 0:
            return True
        
        elif allPieces.count('King') == 2 and allPieces.count('Pawn') == 0 and allPieces.count('Knight') == 0\
        and allPieces.count('Bishop') == 1 and allPieces.count('Rook') == 0 and allPieces.count('Queen') == 0:
            return True
        
        elif allPieces.count('King') == 2 and allPieces.count('Pawn') == 0 and whitePieces.count('Knight') == 1\
        and whitePieces.count('Bishop') == 0 and blackPieces.count('Bishop') == 1 and blackPieces.count('Knight') == 0\
        and allPieces.count('Rook') == 0 and allPieces.count('Queen') == 0:
            return True
        
        elif allPieces.count('King') == 2 and allPieces.count('Pawn') == 0 and whitePieces.count('Knight') == 0\
        and whitePieces.count('Bishop') == 1 and blackPieces.count('Bishop') == 0 and blackPieces.count('Knight') == 1\
        and allPieces.count('Rook') == 0 and allPieces.count('Queen') == 0:
            return True
        
        elif allPieces.count('King') == 2 and allPieces.count('Pawn') == 0 and whitePieces.count('Knight') == 0\
        and whitePieces.count('Bishop') == 1 and blackPieces.count('Bishop') == 1 and blackPieces.count('Knight') == 0\
        and allPieces.count('Rook') == 0 and allPieces.count('Queen') == 0:
            return True
        
        elif allPieces.count('King') == 2 and allPieces.count('Pawn') == 0 and allPieces.count('Knight') == 2\
        and allPieces.count('Bishop') == 0 and allPieces.count('Rook') == 0 and allPieces.count('Queen') == 0:
            return True
        
        return False
    
    def SwitchTurns(self):
        # Resets the valid moves so the previous players valid moves no longer appears on the screen
        self.validPieceMoves = []
        # This 'if else' block is responsible for switching turns
        if self.turn == 'White':
            self.turn = 'Black'
        else:
            self.turn = 'White'

    def NewKingMoves(self, board, row, column, colour):
        if colour == 'White':
            oppColour = 'Black'
            rows = 7
        else:
            oppColour = 'White'
            rows = 0
        kingMoves = self.king.GetValidMoves(board.board, row, column)
        shortCastleMoves = self.king.GetShortCastleMoves(board.board, row, column)
        longCastleMoves = self.king.GetLongCastleMoves(board.board, row, column)

        # Checks if kingside castle conditions are met and the King is not in check
        if board.CanCastleKingside(colour) and self.InCheck(board, colour) == None:
            kingMoves.extend(shortCastleMoves) # Adds the castle moves to the valid moves

        # Checks if queenside castle conditions are met and the King is not in check
        if board.CanCastleQueenside(colour) and self.InCheck(board, colour) == None:
            kingMoves.extend(longCastleMoves) # Adds the castle moves to the valid moves

        enemyPieceData = {'King': [], 'Queen': [], 'Rook': [], 'Bishop': [], 'Knight': [], 'Pawn': []}
        
        for number in range(1, 10):
            for piece in ['King', 'Queen', 'Rook','Bishop', 'Knight', 'Pawn']:
                position = self.PiecePositions(board, piece, oppColour).get(number) # Gets the position of each piece from the key in the dictionary
                if position != None:
                    pieceRow, pieceColumn = position
                    # Dynamically gets the method to calculate control moves for the given piece
                    controlMovesMethod = getattr(self, piece.lower()).GetValidMoves
                    # Adds a dictionary which hold the control to the list of each piece in the enemyPieceData dictionary
                    enemyPieceData[piece].append({
                        'controlMoves': controlMovesMethod(board.board, pieceRow, pieceColumn, 'Control')
                    })

        # Loops through all the values in the enemy piece data dictionary
        for pieceData in enemyPieceData.values():
            for enemyData in pieceData:
                controlMoves = enemyData['controlMoves']

                # Loops through all the initial valid King moves and removes any that are in the control moves of an enemy piece
                for move in kingMoves[:]:
                    if board.board[row][column].piece.colour == colour and move in controlMoves:
                        kingMoves.remove(move)

                    # This prevents kingside castling through a check
                    if move == (rows, 7) and move in kingMoves and (rows, 6) in controlMoves\
                    and board.CanCastleKingside(colour) and board.board[row][column].piece.colour == colour:
                        kingMoves.remove((rows, 7))

                    # This prevents queenside castling through a check
                    if move == (rows, 3) and move in kingMoves and (rows, 4) in controlMoves\
                    and board.CanCastleQueenside(colour) and board.board[row][column].piece.colour == colour:
                        kingMoves.remove((rows, 3))

        return kingMoves

    def NewPieceMoves(self, board, row, column, name, colour):
        if colour == 'White':
            oppColour = 'Black'
        else:
            oppColour = 'White'

        # Dynamically gets the method to calculate control moves for the given piece
        movesMethod = getattr(self, name.lower()).GetValidMoves
        validMoves = movesMethod(board.board, row, column)
        updatedValidMoves = []
        piecePositions = self.PiecePositions(board, name, colour) # Holds the dictionary which stores the positions of the given piece
        pieceKey = self.KeyFromPosition(piecePositions, (row, column)) # Gets the key of each piece using KeyFromPosition method
        kingRow, kingColumn = self.PiecePositions(board, 'King', colour).get(1)

        #This holds the positions of the pieces giving the check
        positions = self.CheckingPiecePosition(board, colour)

        #This stores the list of the different moves for blocking a queen, rook or bishop check
        blockMoves = self.BlockMoves(board, colour)

        enemyPieceData = {'Queen': [], 'Rook': [], 'Bishop': []}
        
        for number in range(1, 10):
            for piece in ['Queen', 'Rook','Bishop']:
                position = self.PiecePositions(board, piece, oppColour).get(number)
                if position != None:
                    pieceRow, pieceColumn = position
                    # Dynamically gets the method to calculate moves for each piece
                    validMovesMethod = getattr(self, piece.lower()).GetValidMoves
                    # Adds to each list for each piece (key) in the enemyPieceData dict another dictionary which holds the position,
                    # the validMoves and the pinMoves of that piece
                    enemyPieceData[piece].append({
                        'position': position,
                        'validMoves': validMovesMethod(board.board, pieceRow, pieceColumn),
                        'pinMoves': validMovesMethod(board.board, pieceRow, pieceColumn, 'Pin')
                    })

        # Checks if the piece is pinned and the king is in check
        if self.PiecePinned(board, name, pieceKey, colour) and self.InCheck(board, colour) != None:
            updatedValidMoves = []

        # Checks if the King is in double check
        elif self.InCheck(board, colour) == 'double':
            updatedValidMoves = []
            
        # Checks if the King is in check by a single piece
        elif self.InCheck(board, colour) == 'single':
            # This checks if the checking piece is in the valid moves of the selected piece and adds it to the updatedValidMoves list
            for position in positions:
                if position in validMoves:
                    updatedValidMoves = [position]

            # This loops through all the possible blocking squares and adds them to the updatedValidMoves list
            for move in blockMoves:
                if move in validMoves:
                    updatedValidMoves.append(move)

        # This checks if the King is not in check and the selected piece is not pinned
        elif self.InCheck(board, colour) == None and self.PiecePinned(board, name, pieceKey, colour) != True:
            updatedValidMoves = validMoves

        # This else block is responsible for handling piece movement restriction when pinned depending on how the pin is and what piece is pinned
        else:
            # Loops through key, value pairs in the enemyPieceData dictionary
            for enemyPiece, pieceData in enemyPieceData.items():
                # Loops through each dictionary in each value (list)
                for enemyData in pieceData:
                    # Assigns to variables the values stored in the embedded dictionary for each piece depending on the key
                    pieceRow, pieceColumn = enemyData['position']
                    pieceMoves = enemyData['validMoves']
                    pinMoves = enemyData['pinMoves']

                    # This handles queen movement restriction when pinned
                    if name == 'Queen' and (row, column) in pieceMoves and (kingRow, kingColumn) in pinMoves:
                        # Checks if the pinning piece is a queen or rook 
                        if enemyPiece == 'Queen' or enemyPiece == 'Rook':
                            # Checks if the queen is pinned horizontally
                            if row == pieceRow:
                                for move in pinMoves:
                                    if move in validMoves and move[0] == row:
                                        updatedValidMoves.append(move) # Adds only moves on the row and none else
                                updatedValidMoves.append((pieceRow, pieceColumn)) # Adds the pinning piece to the updatedValidMoves

                            # Checks if the queen is pinned vertically
                            elif column == pieceColumn:
                                for move in pinMoves:
                                    if move in validMoves and move[1] == column:
                                        updatedValidMoves.append(move) # Adds only moves on the column and none else
                                updatedValidMoves.append((pieceRow, pieceColumn)) # Adds the pinning piece to the updatedValidMoves

                        # Checks if the pinning piece is a bishop or queen
                        if enemyPiece == 'Bishop' or enemyPiece == 'Queen':
                            # Checks if the queen is pinend in the bottom left to top right diagonal or vice versa
                            if (kingRow < pieceRow and kingColumn > pieceColumn) or (kingRow > pieceRow and kingColumn < pieceColumn):
                                for move in pinMoves:
                                    if move in validMoves and move[0] + move[1] == row + column:
                                        updatedValidMoves.append(move) # Adds only moves on the diagonal
                                updatedValidMoves.append((pieceRow, pieceColumn)) # Adds the pinning piece to the updatedValidMoves

                            # Checks if the queen is pinned in the bottom right to top left diagonal or vice versa
                            elif (kingRow > pieceRow and kingColumn > pieceColumn) or (kingRow < pieceRow and kingColumn < pieceColumn):
                                for move in pinMoves:
                                    if move in validMoves and move[0] != pieceRow and move[1] != pieceColumn and move[0] != row and move[1] != column:
                                        updatedValidMoves.append(move) # Adds only moves on the diagonal
                                updatedValidMoves.append((pieceRow, pieceColumn)) # Adds the pinning piece to the updatedValidMoves
    
                    # This handles rook movement restriction when pinned
                    if name == 'Rook' and (row, column) in pieceMoves and (kingRow, kingColumn) in pinMoves:
                        # Checks if the rook is pinned by a queen or rook
                        if enemyPiece == 'Queen' or enemyPiece == 'Rook':
                            # Checks if the rook is pinned horizontally
                            if row == pieceRow:
                                for move in pinMoves:
                                    if move in validMoves and move[0] == row:
                                        updatedValidMoves.append(move) # Adds only moves on the row and none else
                                updatedValidMoves.append((pieceRow, pieceColumn)) # Adds the pinning piece to the updatedValidMoves

                            # Checks if the rook is pinned vertically
                            elif column == pieceColumn:
                                for move in pinMoves:
                                    if move in validMoves and move[1] == column:
                                        updatedValidMoves.append(move) # Adds only moves on the column and none else
                                updatedValidMoves.append((pieceRow, pieceColumn)) # Adds the pinning piece to the updatedValidMoves
                        
                        # Checks if the rook is pinned by a queen or bishop diagonally
                        if (enemyPiece == 'Queen' or enemyPiece == 'Bishop') and row != pieceRow and column != pieceColumn:
                            updatedValidMoves = []

                    # This handles knight movement restriction when pinned
                    if name == 'Knight' and (row, column) in pieceMoves and (kingRow, kingColumn) in pinMoves:
                        updatedValidMoves = []

                    # This handles bishop movement restriction when pinned
                    if name == 'Bishop' and (row, column) in pieceMoves and (kingRow, kingColumn) in pinMoves:
                        # Checks if the bishop is pinned by a queen or bishop 
                        if (enemyPiece == 'Bishop' or enemyPiece == 'Queen'):
                            # Checks if the bishop is pinned in the bottom left to top right diagonal or vice versa
                            if (kingRow < pieceRow and kingColumn > pieceColumn) or (kingRow > pieceRow and kingColumn < pieceColumn):
                                for move in pinMoves:
                                    if move in validMoves and move[0] + move[1] == row + column:
                                        updatedValidMoves.append(move) # Adds only moves on the diagonal
                                updatedValidMoves.append((pieceRow, pieceColumn)) # Adds the pinning piece to the updatedValidMoves

                            # Checks if the bishop is pinned in the bottom right to top left diagonal or vice versa
                            elif (kingRow > pieceRow and kingColumn > pieceColumn) or (kingRow < pieceRow and kingColumn < pieceColumn):
                                for move in pinMoves:
                                    if move in validMoves and move[0] != pieceRow and move[1] != pieceColumn:
                                        updatedValidMoves.append(move) # Adds only moves on the diagonal
                                updatedValidMoves.append((pieceRow, pieceColumn)) # Adds the pinning piece to the updatedValidMoves

                        # Checks if the bishop is pinned by a rook or queen horizontally or vertically
                        if (enemyPiece == 'Queen' or enemyPiece == 'Rook') and (row == pieceRow or column == pieceColumn):
                            updatedValidMoves = []

                    # This handles pawn movement restriction when pinned
                    if name == 'Pawn' and (row, column) in pieceMoves and (kingRow, kingColumn) in pinMoves:
                        # Checks if the pawn is pinned by a queen or rook
                        if enemyPiece == 'Queen' or enemyPiece == 'Rook':
                            # Checks if the pawn is pinned vertically
                            if column == pieceColumn:
                                for move in pinMoves:
                                    if move in validMoves and move[1] == column:
                                        updatedValidMoves.append(move) # Adds only moves on the column and none else so no diagonal captures

                            # Checks if the pawn is pinned horizontally
                            elif row == pieceRow:
                                updatedValidMoves = []

                        # Checks if the pawn is pinned by a bishop or queen diagonally
                        if (enemyPiece == 'Bishop' or enemyPiece == 'Queen') and (row != pieceRow and column != pieceColumn):
                            if (pieceRow, pieceColumn) in validMoves:
                                updatedValidMoves = [(pieceRow, pieceColumn)] # Pawn can only capture pinning piece if in valid moves
                            else:
                                updatedValidMoves = [] # Otherwise it cannot move

        return updatedValidMoves
    
    def InCheck(self, board, colour):
        if colour == 'White':
            oppColour = 'Black'
        else:
            oppColour = 'White'

        kingRow, kingColumn = self.PiecePositions(board, 'King', colour).get(1)
        count = 0 # Variable to track the number of enemy pieces that the King's position is in

        # Dictionary which holds data of all pieces that can give a check
        enemyPieceData = {'Queen': [], 'Rook': [], 'Bishop': [], 'Knight': [], 'Pawn': []}
        
        for number in range(1, 10):
            for piece in ['Queen', 'Rook','Bishop', 'Knight', 'Pawn']:
                position = self.PiecePositions(board, piece, oppColour).get(number) # Gets the piece position from the key in the EnemyPiecePositon dict.
                if position != None:
                    pieceRow, pieceColumn = position
                    # Dynamically gets the method to calculate valid moves for each piece
                    validMovesMethod = getattr(self, piece.lower()).GetValidMoves
                    # Adds to the list for each piece in the enemyPieceData dict its valid moves
                    enemyPieceData[piece].append({
                        'validMoves': validMovesMethod(board.board, pieceRow, pieceColumn)
                    })

        # Loops through all the values (lists) in the enemyPieceData dictionary
        for pieceData in enemyPieceData.values():
            # Loops through all the dictionaries in each list
            for enemyData in pieceData:
                validMoves = enemyData['validMoves']

                # Checks if the King's position is in the valid moves of any enemy piece
                if (kingRow, kingColumn) in validMoves:
                    count += 1 # Increments the count by 1

        # Checks if the King's position is in the valid moves of two enemy pieces
        if count == 2:
            return 'double'
        # Checks if the King's position is in the valid move of a single enemy piece
        elif count == 1:
            return 'single'
        
        return None # Else it returns None

    def PieceCheck(self, board, piece, number, colour):
        if colour == 'White':
            oppColour = 'Black'
        else:
            oppColour = 'White'

        oppPiecePosition = self.PiecePositions(board, piece, oppColour).get(number)
        kingRow, kingColumn = self.PiecePositions(board, 'King', colour).get(1)

        if oppPiecePosition != None:
            oppPieceRow, oppPieceColumn = oppPiecePosition
            # Dynamically gets the method to calculate valid moves for each enemy piece
            movesMethod = getattr(self, piece.lower()).GetValidMoves
            oppPieceMoves = movesMethod(board.board, oppPieceRow, oppPieceColumn)
        else:
            oppPieceMoves = []

        # This checks if the King is in the enemy piece's moves and returns the position of the checking piece
        if (kingRow, kingColumn) in oppPieceMoves:
            return oppPieceRow, oppPieceColumn
        
    def BlockPieceCheck(self, board, piece, number, colour):
        moves = []
        piecePosition = self.PieceCheck(board, piece, number, colour)
        kingRow, kingColumn = self.PiecePositions(board, 'King', colour).get(1)
        movesMethod = getattr(self, piece.lower()).GetValidMoves

        if piecePosition != None:
            pieceRow, pieceColumn = piecePosition

            # Checks if the checking piece is a queen or a bishop and the 'check' is done diagonally
            if (piece == 'Queen' or piece == 'Bishop') and (pieceRow != kingRow and pieceColumn != kingColumn):
                # Checks if the king is in the bottom right direction of the queen
                if pieceRow < kingRow and pieceColumn < kingColumn:
                    # Checks the squares between the king and the queen
                    for row in range(pieceRow + 1, kingRow):
                        for column in range(pieceColumn + 1, kingColumn):
                            # Checks if the squares checked by the for loop are in the valid moves of the queen from that position
                            # and if they are, they are added to moves.
                            if (row, column) in movesMethod(board.board, pieceRow, pieceColumn):
                                moves.append((row, column))

                # Checks if the king is in the bottom left direction of the queen
                elif pieceRow < kingRow and pieceColumn > kingColumn:
                    # Checks the squares between the king and the queen
                    for row in range(pieceRow + 1, kingRow):
                        for column in range(kingColumn + 1, pieceColumn):
                            # Checks if the squares checked by the for loop are in the valid moves of the queen from that position
                            # and if they are, they are added to moves.
                            if (row, column) in movesMethod(board.board, pieceRow, pieceColumn):
                                moves.append((row, column))

                # Checks if the king is in the top right direction of the queen
                elif pieceRow > kingRow and pieceColumn < kingColumn:
                    # Checks the squares between the king and the queen
                    for row in range(kingRow + 1, pieceRow):
                        for column in range(pieceColumn + 1, kingColumn):
                            # Checks if the squares checked by the for loop are in the valid moves of the queen from that position
                            # and if they are, they are added to moves.
                            if (row, column) in movesMethod(board.board, pieceRow, pieceColumn):
                                moves.append((row, column))

                # Checks if the king is in the top left direction of the queen
                elif pieceRow > kingRow and pieceColumn > kingColumn:
                    # Checks the squares between the king and the queen
                    for row in range(kingRow + 1, pieceRow):
                        for column in range(kingColumn + 1, pieceColumn):
                            # Checks if the squares checked by the for loop are in the valid moves of the queen from that position
                            # and if they are, they are added to moves.
                            if (row, column) in movesMethod(board.board, pieceRow, pieceColumn):
                                moves.append((row, column))

            # Checks if the checking piece is a queen or a rook and the 'check' is done rectilinearly
            if (piece == 'Queen' or piece == 'Rook') and (pieceRow == kingRow or pieceColumn == kingColumn):
                # Checks if the king is below the rook and they are both on the same column
                if pieceRow < kingRow and pieceColumn == kingColumn:
                    # This for loop is then used to check all the squares between the king and the rook and then adds them to moves
                    for row in range(pieceRow + 1, kingRow):
                        moves.append((row, pieceColumn))

                # Checks if the king is above the rook and they're on the same column
                elif pieceRow > kingRow and pieceColumn == kingColumn:
                    # This also checks all the squares between the king and rook and adds them to moves
                    for row in range(kingRow + 1, pieceRow):
                        moves.append((row, pieceColumn))

                # Checks if the king and rook are on the same row and the king is to the right of the rook
                elif pieceRow == kingRow and pieceColumn < kingColumn:
                    # Adds all the squares between the king and rook in this scenario to moves
                    for column in range(pieceColumn + 1, kingColumn):
                        moves.append((pieceRow, column))

                # Checks if the king and rook are on the same row and the king is to the left of the rook
                elif pieceRow == kingRow and pieceColumn > kingColumn:
                    # Adds all the squares between the king and rook to moves
                    for column in range(kingColumn + 1, pieceColumn):
                        moves.append((pieceRow, column))

        return moves
    
    def PiecePinned(self, board, name, key, colour):
        kingInSight = False

        if colour == 'White':
            oppColour = 'Black'
        else:
            oppColour = 'White'

        piecePosition = self.PiecePositions(board, name, colour).get(key)
        enemyPieceData = {'Queen': [], 'Rook': [], 'Bishop': []}

        if piecePosition != None:
            pieceRow, pieceColumn = piecePosition

        kingRow, kingColumn = self.PiecePositions(board, 'King', colour).get(1)

        for number in range(1, 10):
            for piece in ['Queen', 'Rook', 'Bishop']:
                position = self.PiecePositions(board, piece, oppColour).get(number)
                if position != None:
                    enemyPieceRow, enemyPieceColumn = position
                    # Dynamically gets the method for calculating the moves of each enemy piece
                    validMovesMethod = getattr(self, piece.lower()).GetValidMoves
                    # Adds to each list for each piece (key) in the enemyPieceData dict another dictionary which holds the position,
                    # the validMoves and the pinMoves of that piece
                    enemyPieceData[piece].append({
                        'position': position,
                        'validMoves': validMovesMethod(board.board, enemyPieceRow, enemyPieceColumn),
                        'pinMoves': validMovesMethod(board.board, enemyPieceRow, enemyPieceColumn, 'Pin')
                    })

        # Loops through all the key, value pairs of the enemyPieceData dictionary
        for enemyPiece, pieceData in enemyPieceData.items():
            # Loops through all the dictionaries in each value (list)
            for enemydata in pieceData:
                enemyPieceRow, enemyPieceColumn = enemydata['position']
                enemyPieceMoves = enemydata['validMoves']
                enemyPinMoves = enemydata['pinMoves']

                # Handles conditions for checking if a piece is pinned by a queen or rook rectilinearly
                if enemyPiece == 'Queen' or enemyPiece == 'Rook':
                    # Checks if the piece is on the same vertical file as the king and rook and the king is below the rook
                    if (pieceColumn == enemyPieceColumn == kingColumn) and (enemyPieceRow < pieceRow < kingRow)\
                    and (pieceRow, pieceColumn) in enemyPieceMoves:
                        kingInSight = True

                        squaresEmpty = True
                        for row in range(pieceRow + 1, kingRow):
                            # Checks if the squares between the piece and king are not empty or the king is directly below the piece
                            if board.board[row][enemyPieceColumn].piece != None:
                                squaresEmpty = False
                                break
                        
                        # This then checks if both condtions have been satisfied for the piece to be considered pinned
                        if kingInSight and squaresEmpty:
                            return True
                        
                    # Checks if the piece is on the same row as the king and rook and the king is to the left of the rook
                    elif (pieceRow == enemyPieceRow == kingRow) and (kingColumn < pieceColumn < enemyPieceColumn)\
                    and (pieceRow, pieceColumn) in enemyPieceMoves:
                        kingInSight = True

                        squaresEmpty = True
                        for column in range(kingColumn + 1, pieceColumn):
                            # Checks if the squares between the piece and king are not empty or the king is directly to the left of the piece
                            if board.board[enemyPieceRow][column].piece != None:
                                squaresEmpty = False
                                break
                            
                        # This then checks if both condtions have been satisfied for the piece to be considered pinned
                        if kingInSight and squaresEmpty:
                            return True
                        
                    # This is similar to the if block but just checks if the king is above instead of below 
                    elif (pieceColumn == enemyPieceColumn == kingColumn) and (kingRow < pieceRow < enemyPieceRow)\
                    and (pieceRow, pieceColumn) in enemyPieceMoves:
                        kingInSight = True

                        squaresEmpty = True
                        for row in range(kingRow + 1, pieceRow):
                            # Checks if the squares between the piece and the king are not empty or the king is directly above the piece
                            if board.board[row][enemyPieceColumn].piece != None:
                                squaresEmpty = False
                                break

                        # This then checks if both condtions have been satisfied for the piece to be considered pinned
                        if kingInSight and squaresEmpty:
                            return True
                        
                    # This is similar to the previous elif block but just checks if the king is to the right instead of the left of the rook or queen
                    elif (pieceRow == enemyPieceRow == kingRow) and (enemyPieceColumn < pieceColumn < kingColumn)\
                    and (pieceRow, pieceColumn) in enemyPieceMoves:
                        kingInSight = True

                        squaresEmpty = True
                        for column in range(pieceColumn + 1, kingColumn):
                            # This checks if the squares between the king and the piece are not empty or the king is directly to the right of the piece
                            if board.board[enemyPieceRow][column].piece != None:
                                squaresEmpty = False
                                break

                        # This then checks if both condtions have been satisfied for the piece to be considered pinned 
                        if kingInSight and squaresEmpty:
                            return True

                # Handles conditions for checking if a piece is pinned by a queen or bishop diagonally
                if enemyPiece == 'Queen' or enemyPiece == 'Bishop':
                    # This checks if the piece is between the bishop and king in the top-left to bottom-right diagonal
                    if (enemyPieceRow < pieceRow < kingRow) and (enemyPieceColumn < pieceColumn < kingColumn)\
                    and (pieceRow, pieceColumn) in enemyPieceMoves and (kingRow, kingColumn) in enemyPinMoves:
                        kingInSight = True

                        squaresEmpty = True
                        squares = kingRow - pieceRow

                        for i in range(1, squares): 
                            # This ensures that only diagonals are considered
                            row  = pieceRow + i 
                            column = pieceColumn + i
                            # This checks if the squares between the piece and king are occupied 
                            if board.board[row][column].piece != None: 
                                squaresEmpty = False 
                                break 

                        # This then checks if both condtions have been satisfied for the piece to be considered pinned
                        if kingInSight and squaresEmpty: 
                            return True

                    # This checks if the piece is between the bishop and king in the top-right to bottom-left diagonal
                    elif (enemyPieceRow < pieceRow < kingRow) and (kingColumn < pieceColumn < enemyPieceColumn)\
                    and (pieceRow, pieceColumn) in enemyPieceMoves and (kingRow, kingColumn) in enemyPinMoves:
                        kingInSight = True

                        squaresEmpty = True
                        squares = kingRow - pieceRow

                        # Uses same logic as previous elif block
                        for i in range(1, squares):
                            # This ensures the only the diagonals are checked
                            row  = pieceRow + i
                            column = pieceColumn - i

                            # This checks if the squares between the piece and king are occupied
                            if board.board[row][column].piece != None:
                                squaresEmpty = False
                                break
                        # This then checks if both condtions have been satisfied for the piece to be considered pinned
                        if kingInSight and squaresEmpty:
                            return True
                    
                    # This checks if the piece is between the bishop and king in the bottom-left to top-right diagonal
                    elif (kingRow < pieceRow < enemyPieceRow) and (enemyPieceColumn < pieceColumn < kingColumn)\
                    and (pieceRow, pieceColumn) in enemyPieceMoves and (kingRow, kingColumn) in enemyPinMoves:
                        kingInSight = True

                        squaresEmpty = True
                        squares = pieceRow - kingRow

                        # Uses same logic as previous elif block
                        for i in range(1, squares):
                            # This ensures the only the diagonals are checked.
                            row  = pieceRow - i
                            column = pieceColumn + i

                            # This checks if the squares between the piece and king are occupied
                            if board.board[row][column].piece != None:
                                squaresEmpty = False
                                break
                        # This then checks if both condtions have been satisfied for the piece to be considered pinned
                        if kingInSight and squaresEmpty:
                            return True
                        
                    # This checks if the piece is between the bishop and king in the bottom-right to top-left diagonal
                    elif (kingRow < pieceRow < enemyPieceRow) and (kingColumn < pieceColumn < enemyPieceColumn)\
                    and (pieceRow, pieceColumn) in enemyPieceMoves and (kingRow, kingColumn) in enemyPinMoves:
                        kingInSight = True

                        squaresEmpty = True
                        squares = pieceRow - kingRow

                        # Uses same logic as previous elif block
                        for i in range(1, squares):
                            #This ensures the only the diagonals are checked.
                            row  = pieceRow - i
                            column = pieceColumn - i

                            # This checks if the squares between the piece and king are occupied
                            if board.board[row][column].piece != None:
                                squaresEmpty = False
                                break
                        # This then checks if both condtions have been satisfied for the piece to be considered pinned
                        if kingInSight and squaresEmpty:
                            return True
                        
    # This method gets the total material value of the given player depending on colour
    def Material(self, board, colour):
        materialValue = 0

        # Checks all squares on the board it is given
        for row in range(0, 8):
            for column in range(1, 9):
                # Checks if a piece has been encountered and its colour is the same as the colour parameter
                if board.board[row][column].piece != None and board.board[row][column].piece.colour == colour:
                    materialValue += board.board[row][column].piece.value # Adds its relative value to material value

        return materialValue
    
    # This method calculates how much more/less material black has than white
    def MaterialEvaluation(self, board):
        return self.Material(board, 'Black') - self.Material(board, 'White')
    
    # This method holds the positions of all the pieces of a certain colour
    def AllPiecePositions(self, board, colour):
        positions = []

        # The two for loops ensure all squares on the board are checked
        for row in range(0, 8):
            for column in range(1, 9):
                # This adds the positions of all the pieces of the chosen player (depending on colour) to the positions list
                if board.board[row][column].piece != None and board.board[row][column].piece.colour == colour:
                    positions.append((row, column))

        return positions

    # This method encourages the AI to have at least 2 pawns in the centre
    def CentralPresence(self, board):
        score = 0

        # Stores the central two forward squares for the black pawns
        centralSquares = [(3, 4), (3, 5)]

        # Loops through the positions of all black pawn
        for pos in self.PiecePositions(board, 'Pawn', 'Black').values():
            # Checks if their current position is in the central squares list
            if pos in centralSquares:
                    score += 1 # Adds 1 to score to encourage the AI to have 2 pawns in the centre at least

        return score
    
    # This method is used to check the controlled squares of friendly pieces
    def PieceDefenseMoves(self, board, colour):
        positions = []
        moves = []
        for row in range(0, 8):
            for column in range(1, 9):
                # This adds the positions of all the pieces of the current player to the positions list
                if board.board[row][column].piece != None and board.board[row][column].piece.colour == colour:
                    positions.append((row, column))

        # This loops through all the values now in the positions list and gets the piece using the row and column
        for pos in positions:
            piece = board.PieceAtSquare(pos[0], pos[1])
            movesMethod = getattr(self, piece.name.lower()).GetValidMoves
            # Depending on the piece, it adds it control moves to the moves list accordingly
            moves.extend(movesMethod(board.board, pos[0], pos[1], 'Control'))

        return moves

    # This method is used to ensure a piece does not move to a square controlled by more enemy pieces than defended by friendly pieces
    def Defense(self, board):
        score = 0
        attackCount = 0 # Variable to store the number of enemy pieces that attack a square/friendly piece
        defenseCount = 0 # Variable to store the number of friendly piece that defend a square/friendly piece

        enemyPieceMoves = self.AllPieceMoves(board, 'White') # Holds a squares controlled by an enemy piece
        friendlyDefenseMoves = self.PieceDefenseMoves(board, 'Black') # Holds all squares controlled by a friendly piece

        # Ensure the positions all black pieces are checked
        for piece in ['Queen', 'Rook', 'Bishop', 'Knight', 'Pawn']:
            piecePositions = self.PiecePositions(board, piece, 'Black')

            # Loops through the positions of all black pieces excluding the king
            for pos in piecePositions.values():
                # Checks if the piece is in a square controlled by an enemy piece
                if pos != None and pos in enemyPieceMoves:
                    attackCount += 1 # Increments the attack count
                    # Checks if the piece is in a square controlled by a friendly piece
                    if pos in friendlyDefenseMoves:
                        defenseCount += 1 # Increments the defense count

        # Checks if the number of pieces attacking piece is greater than the number of pieces defending it.
        if attackCount > defenseCount:
            score -= 7 * (attackCount - defenseCount) # Reduces the score by a lot to discourage moving to such positions

        return score
    
    # This method encourages the AI to move a piece with a higher value if attacked by a piece with a lower value
    def HighValueAttacked(self, board):
        score = 0
         # I manually stored the relative values in this dictionary so its easier to access
        pieceMappings = {'Queen': 9, 'Rook': 5, 'Bishop': 3, 'Knight': 3, 'Pawn': 1}

        # Only checks from pawn to a rook because the queen is the highest value piece (after the king)
        for enemyPiece in ['Pawn', 'Bishop', 'Knight', 'Rook']:
            enemyPieceMoves = self.PieceMoves(board, enemyPiece, 'White') # Stores all of white's moves depending on the piece
    
            # Ensures the positions of all friendly pieces are checked excluding the pawn because it has the lowest value
            for friendlyPiece in ['Queen', 'Rook', 'Bishop', 'Knight']:
                piecePositions = self.PiecePositions(board, friendlyPiece, 'Black')

                # Loops through all positions of the current friendly piece
                for pos in piecePositions.values():
                    # Loops through all the move lists of an enemy piece
                    for move in enemyPieceMoves.values():
                        # Checks if the friendly piece is in the valid moves of an enemy piece with a lower relative value
                        if pos != None and pos in move and pieceMappings[enemyPiece] < pieceMappings[friendlyPiece]:
                            # Reduces the score by a lot to encourage the AI to move the piece away
                            score -= 6 * (pieceMappings[friendlyPiece] - pieceMappings[enemyPiece])
                            
        return score
    
    # This method checks if the King is castled, manually
    def IsCastled(self, board, side):
        moved = False
        kingsRook = False # Variables to track if the kings rook is on the correct castled square
        queensRook = False # Variables to track if the queens rook is on the correct castled square
        kingRow, kingColumn = self.PiecePositions(board, 'King', 'Black').get(1)
        rookPositions = self.PiecePositions(board, 'Rook', 'Black') # Stores the positions of the two black rooks

        # Checks the positions of the rooks
        for pos in rookPositions.values():
            # Checks if the rook exists and its on the short castled square not castling square so (0, 6) and not (0, 8)
            if pos != None and pos == (0, 6):
                kingsRook = True
            
            # Checks if the rook exists and its on the long castled square not the castling square so (0, 4) and not (0, 1)
            elif pos != None and pos == (0, 4):
                queensRook = True

        # Checks if the king and rook are on the short castled squares and the king's rook original square is empty 
        if board.board[0][8].piece == None and (kingRow, kingColumn) == (0, 7) and kingsRook and side == 'kingside' and not moved:
            moved = True
            return True
        
        # Checks if the king and queens rook are on the long castled squares and the queen's rook original square is empty as well as the one next to it
        if board.board[0][1].piece == None and board.board[0][2].piece == None and (kingRow, kingColumn) == (0, 3)\
        and queensRook and side == 'queenside' and not moved:
            moved = True
            return True
        
        return False
    
    # This is where all the separate evaluations are added up to produce a final one for the medium AI
    def MediumEvaluation(self, board):
        numMoves = 0 # Variable to track the number of moves the AI has
        positionalScore = 0  # Initialises a positional score for some positional advantages
        centralControl = self.CentralPresence(board) # Stores the pawn central control score
        positiveAdvantage = 0

        materialAdvantage = self.MaterialEvaluation(board) # Stores the difference in material between black and white
    
        # Checks if white has more material value than black
        if materialAdvantage < 0:
            positionalScore += 4 * materialAdvantage # This reduces positional score by 4 times the deficit to encourage capturing back

        # Checks if black has more material value than white
        if materialAdvantage > 0:
            positiveAdvantage += 1.5 * materialAdvantage # Increases the score by a smaller amount to prevent the AI from capturing defended pieces

        # Checks if the black king is castled queenside or kingside (i.e short or long)
        if self.IsCastled(board, 'kingside') or self.IsCastled(board, 'queenside'):
            positionalScore += 5 # Increases the positional score so it encourages the AI to castle its king
        
        # Checks if the black king can castle queenside or kingside
        if board.CanCastleKingside('Black') or board.CanCastleQueenside('Black'):
            positionalScore += 2.5 # Increases the positional score so it encourages the AI to be in a position that it can castle

        # This checks the valid moves of all pieces excluding the king
        for piece in ['Queen', 'Rook', 'Bishop', 'Knight', 'Pawn']:
            validMoves = self.PieceMoves(board, piece, 'Black')

            # Loops through all the move lists for each piece
            for move in validMoves.values():
                numMoves += len(move) # Adds the length of each list to numMoves so the AI can prioritise activating its pieces

        # Allows the AI to find checkmate in 1 if possible
        if self.Checkmate(board, 'White'):
            positionalScore += 100000000

        # Checks if the AI can move
        if numMoves > 0:
            # Takes a logarithm of the no. of moves so it doesn't contribute too much a factor into the evaluation
            mobilityScore = math.log(numMoves)
        else:
            mobilityScore = 0

        # Returns all the evaluations added together, some of them have been multiplied by certain amounts to reduce their influence further
        return mobilityScore * 0.6 + positionalScore + self.Defense(board) + self.HighValueAttacked(board)\
        + centralControl * 0.8 + positiveAdvantage
    
    def GamePhases(self, board):
        phase = None
        if len(self.AllPieces(board)) >= 25:
            phase = 'Opening'
        elif 15 <= len(self.AllPieces(board)) < 25:
            phase = 'Middlegame'
        elif len(self.AllPieces(board)) < 15:
            phase = 'Endgame'

        return phase

    def UsefulMoves(self, board, colour):
        if colour == 'White':
            oppColour = 'Black'
        else:
            oppColour = 'White'
        moves = []
        enemyMoves = self.AllPieceMoves(board, oppColour)
        friendlyMoves = self.AllPieceMoves(board, colour)

        moves.append(friendlyMoves)

        for move in moves[:]:
            if move in enemyMoves:
                moves.remove(move)

        return moves

    def AttackUndefended(self, board):
        score = 0
        undefendedPiecePositions = []
        enemyPiecePositions = self.AllPiecePositions(board, 'White')
        enemyKingPosition = self.PiecePositions(board, 'King', 'White').get(1)
        if self.GamePhases(board) == 'Opening':
            enemyPiecePositions.remove(enemyKingPosition)

        for positions in enemyPiecePositions:
            if positions not in self.PieceDefenseMoves(board, 'White'):
                undefendedPiecePositions.append(positions)

        for move in self.AllPieceMoves(board, 'Black'):
            if move in undefendedPiecePositions:
                score += 2

        return score

    def AttackBonuses(self, board):
        pass

    def PawnBreaks(self, board):
        score = 0
        if self.GamePhases(board) == 'Middlegame' or self.GamePhases(board) == 'Opening':
            if len(self.UsefulMoves(board, 'White')) - len(self.UsefulMoves(board, 'Black')) >= 5:
                enemyPawnMoves = self.PieceMoves(board, 'Pawn', 'White')
                friendlyPawnPositions = self.PiecePositions(board, 'Pawn', 'Black')

                for pos in friendlyPawnPositions.values():
                    if pos in enemyPawnMoves.values():
                        score += 2

        return score

    def PromotionBonus(self, board):
        score = 0
        rows = []
        squaresEmpty = True
        if self.GamePhases(board) == 'Endgame':
            pawnPositions = self.PiecePositions(board, 'Pawn', 'Black')
            for number in range(1, 9):
                position = pawnPositions.get(number)
                if position != None:
                    rows.append(position[0])

            for pos in pawnPositions.values():
                if pos != None:
                    for row in range(pos[0] + 1, 8):
                        if board.board[row][pos[1]].piece != None:
                            squaresEmpty = False
                            break

                if pos != None and squaresEmpty and pos[0] == max(rows):
                    score += 7 + pos[0]
                    break

        return score
                    
    def FairCapture(self, board):
        pass

    def CheckBonus(self, board):
        total = 0
        score = 0
        if self.InCheck(board, 'White') != None:
            total += len(self.AllPieceMoves(board, 'White'))

        if total < 4:
            score += 1.8

        return score
    
    def HardEvaluation(self, board):
        mediumEval = self.MediumEvaluation(board)

        if self.GamePhases(board) == 'Endgame':
            return self.PromotionBonus(board) + self.CheckBonus(board) + mediumEval + self.AttackUndefended(board)

        else:
            return mediumEval + self.CheckBonus(board) + self.PawnBreaks(board) + self.AttackUndefended(board)
    
                